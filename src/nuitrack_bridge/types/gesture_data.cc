#include "nuitrack_bridge/types/gesture_data.h"


// This header is generated by CXX from the gesture.rs file,
// giving us access to the Rust-defined types in C++.
#include "nuitrack-rs/src/nuitrack_bridge/types/gesture.rs.h"
#include <iostream>

namespace nuitrack_bridge::gesture_data {

    // --- GestureData Implementations ---

    uint64_t getGestureDataTimestamp(const GestureData& data) {
        return data.getTimestamp();
    }

    int32_t getGestureDataNumGestures(const GestureData& data) {
        return static_cast<int32_t>(data.getNumGestures());
    }

    rust::Slice<const Gesture> getGestureDataGestures(const GestureData& data) {
        const auto& vec = data.getGestures();
        std::cout << "--- Gesture FFI Debug ---" << std::endl;
        std::cout << "C++ tdv::nuitrack::Gesture size: " << sizeof(tdv::nuitrack::Gesture) << std::endl;
        std::cout << "Rust nuitrack_bridge::gesture::Gesture size: " << sizeof(Gesture) << std::endl;
        std::cout << "Vector size (element count): " << vec.size() << std::endl;

         if (!vec.empty()) {
            const tdv::nuitrack::Gesture& first_gesture = vec[0];
            std::cout << "Vector data address: " << static_cast<const void*>(vec.data()) << std::endl;
            std::cout << "First gesture user ID: " << first_gesture.userId << std::endl;
            std::cout << "First gesture type (as int): " << static_cast<int>(first_gesture.type) << std::endl;
            std::cout << "sizeof int" << sizeof(int) << std::endl;
            std::cout << "sizeof std::int32_t" << sizeof(::std::int32_t) << std::endl;
        }
        std::cout << "-------------------------" << std::endl;
        return rust::Slice<const Gesture>{
            reinterpret_cast<const Gesture*>(vec.data()),
            vec.size()
        };
    }

    // --- UserStateData Implementations ---

    uint64_t getUserStateDataTimestamp(const UserStateData& data) {
        return data.getTimestamp();
    }

    int32_t getUserStateDataNumUserStates(const UserStateData& data) {
        return static_cast<int32_t>(data.getNumUserStates());
    }

    rust::Slice<const UserState> getUserStateDataUserStates(const UserStateData& data) {
        const auto& vec = data.getUserStates();
        return rust::Slice<const UserState>{
            reinterpret_cast<const UserState*>(vec.data()),
            vec.size()
        };
    }

    // --- UserGesturesStateData Implementations ---

    uint64_t getUserGesturesStateDataTimestamp(const UserGesturesStateData& data) {
        return data.getTimestamp();
    }

    int32_t getUserGesturesStateDataNumUsers(const UserGesturesStateData& data) {
        return static_cast<int32_t>(data.getNumUsers());
    }

    std::unique_ptr<std::vector<UserGesturesState>> getUserGesturesStateDataUserGesturesStates(const UserGesturesStateData& data) {
        // This returns a std::vector by value, so we wrap it in a unique_ptr for Rust.
        return std::make_unique<std::vector<UserGesturesState>>(data.getUserGesturesStates());
    }

}