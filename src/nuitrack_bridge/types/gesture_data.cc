#include "nuitrack_bridge/types/gesture_data.h"


// This header is generated by CXX from the gesture.rs file,
// giving us access to the Rust-defined types in C++.
#include "nuitrack-rs/src/nuitrack_bridge/types/gesture.rs.h"
#include <iostream>

namespace nuitrack_bridge::gesture_data {

    // --- GestureData Implementations ---

    uint64_t getGestureDataTimestamp(const GestureData& data) {
        return data.getTimestamp();
    }

    int32_t getGestureDataNumGestures(const GestureData& data) {
        return static_cast<int32_t>(data.getNumGestures());
    }

    // Change the return type from rust::Slice<...> to rust::Vec<Gesture>
    rust::Vec<Gesture> getGestureDataGestures(const GestureData& data) {
        // This returns a temporary std::vector, which is the source of the bug.
        const auto cpp_temp_vec = data.getGestures();

        // Create a rust::Vec to build the final return value.
        rust::Vec<Gesture> rust_vec;

        // Manually copy the data from the temporary C++ vector
        // into our safe, owned Rust vector.
        for (const tdv::nuitrack::Gesture& cpp_gesture : cpp_temp_vec) {
            Gesture rust_gesture;
            rust_gesture.userId = cpp_gesture.userId;
            rust_gesture.type = static_cast<nuitrack_bridge::gesture::GestureType>(cpp_gesture.type);
            rust_vec.push_back(rust_gesture);
        }

        // Return the owned rust::Vec. CXX will safely move this to the Rust side.
        return rust_vec;
    }

    // --- UserStateData Implementations ---

    uint64_t getUserStateDataTimestamp(const UserStateData& data) {
        return data.getTimestamp();
    }

    int32_t getUserStateDataNumUserStates(const UserStateData& data) {
        return static_cast<int32_t>(data.getNumUserStates());
    }

    rust::Vec<UserState> getUserStateDataUserStates(const UserStateData& data) {
        const auto cpp_temp_vec = data.getUserStates();
        rust::Vec<UserState> rust_vec;

        for (const tdv::nuitrack::UserState& cpp_state : cpp_temp_vec) {
            UserState rust_state;
            rust_state.userId = cpp_state.userId;
            rust_state.state = static_cast<nuitrack_bridge::gesture::UserStateType>(cpp_state.state);
            rust_vec.push_back(rust_state);
        }
        return rust_vec;
    }

    // --- UserGesturesStateData Implementations ---

    uint64_t getUserGesturesStateDataTimestamp(const UserGesturesStateData& data) {
        return data.getTimestamp();
    }

    int32_t getUserGesturesStateDataNumUsers(const UserGesturesStateData& data) {
        return static_cast<int32_t>(data.getNumUsers());
    }

    std::unique_ptr<std::vector<UserGesturesState>> getUserGesturesStateDataUserGesturesStates(const UserGesturesStateData& data) {
        // This returns a std::vector by value, so we wrap it in a unique_ptr for Rust.
        return std::make_unique<std::vector<UserGesturesState>>(data.getUserGesturesStates());
    }

}